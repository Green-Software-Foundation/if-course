# Expanded Overview of Impact Framework Concepts

The Impact Framework (IF) is an **open-source project** with the primary aim of making the environmental impacts of software **easier to calculate and share**. It empowers users to determine the ecological footprint of their software applications, focusing on key metrics such as **carbon emissions**, water usage, and energy consumption. By providing a structured and transparent methodology, IF seeks to facilitate a deeper understanding and ultimately the reduction of these impacts. The framework achieves this through the central use of **manifest files**, which act as the foundation for all calculations. For more information, see the **Welcome to Impact Framework** page.

## In-Depth Look at Manifest Files

At the core of the Impact Framework lies the **manifest file**, a document written in the **human-readable YAML format**. This file is far more than just a configuration; it is considered an **executable audit**. This designation arises from the fact that a single manifest file **contains all the necessary configurations, definitions of the application's architecture, the input data required for analysis, and the specific pipeline of calculations** that Impact Framework will execute. Think of a manifest file as a detailed recipe, outlining every step from ingredients (data) to the final dish (impact assessment) for your software's environmental footprint.

The structure of a manifest file is fundamentally divided into two main sections: the **context** and the **tree**.

*   The **context** encompasses everything located above the `tree` keyword within the YAML file. This section provides **global information** essential for the framework's operation. It includes **metadata** about the manifest itself, such as its `name`, a more detailed `description`, and `tags` that can be used for categorisation. Importantly, the context also houses the **`initialize` section**, where all the **plugins** that will be used in the environmental impact calculations are **defined and configured**. Plugins, which are reusable units of code, must be declared in this section before they can be invoked later in the manifest. The `initialize` section specifies the `method` (the function within the plugin to be executed) and the `path` to the plugin code (e.g., `builtin` for standard library plugins). It can also include an optional `config` field for setting parameters that are common to a plugin's usage throughout the entire manifest. Furthermore, the `initialize` block offers the capability for **parameter mapping**, allowing users to rename arguments expected or returned by plugins, thereby enhancing flexibility and avoiding the need for additional renaming plugins. Users can also add or override parameter metadata within the `initialize` section, which is particularly relevant for the `explainer` feature of IF. The **`execution` section** is another part of the context, but it is **auto-generated by Impact Framework at runtime**. It provides crucial details about the environment in which the manifest was executed, including the execution `status` (success or fail), the exact `command` used, environment details such as the operating system and Node.js version, and any `error` messages encountered. Similarly, the **`explain` section** is also **auto-generated**, listing all the parameter metadata that IF can extract from the plugin instances used in the manifest.

*   The **tree** section, located below the `tree` keyword, **describes the architecture of the system** being analysed. It is organised as a **hierarchical structure**, where each **component** of the system (e.g., a server, a database, a network element) is represented as a **node** in the tree. These components can be nested to reflect the real-world structure of the application. Within each component, you can find a `pipeline` defining the sequence of plugins to be executed, an `inputs` array containing the observation data for that component over time, and optional `defaults` providing fallback values for input parameters that might be missing in certain observations. If a component does not define its own `pipeline` or `defaults`, these are **inherited from the closest parent component** in the tree. The `inputs` field is an array of **observations**, where each observation typically includes a `timestamp` and a `duration`, along with the specific metrics being measured for that time period.

For more information, refer to the **Manifest File** documentation.

## Understanding Observations and Their Impact

The process of environmental impact assessment within Impact Framework begins with **observations**. These are the **raw measurements or data points that are collected about the software application and its underlying infrastructure**. Observations can take many forms, including **direct measurements** like power consumption or network data transfer, as well as **proxy metrics** such as CPU utilisation, memory usage, or even higher-level application metrics like the number of requests served or page views. The **granularity of these observations over time** is crucial, as more frequent data points generally lead to a more accurate impact assessment. The `inputs` array within each component of the manifest file's tree holds these time-series observations.

**Impacts**, on the other hand, are the **environmental consequences that are calculated from these raw observations**. These are the metrics that Impact Framework ultimately aims to quantify, such as **carbon emissions (expressed in gCO2e)**, energy consumption (in kWh), water usage, or even broader indicators like a Software Carbon Intensity (SCI) score. The transition from raw observations to meaningful impact metrics is facilitated by the use of **plugins** and their sequential execution within **pipelines**. For example, an observation of CPU utilisation might be fed into a plugin that, using a power curve model and information about the processor's thermal design power, estimates the energy consumed by the CPU. This estimated energy can then be passed to another plugin that, considering the carbon intensity of the electricity grid, calculates the associated carbon emissions. This step-by-step transformation, where observations are processed through a series of models (implemented as plugins) to yield environmental impacts, is a core principle of Impact Framework. Consult the **Introduction** documentation for a broader understanding.

## The Role of Plugins: Modular Building Blocks

**Plugins** are the **fundamental building blocks of the Impact Framework**. They are **self-contained units of code** designed to perform a **single, specific task**. This modularity is a key design principle, allowing for the creation of complex impact assessment procedures by chaining together simple, individual plugins. Plugins can serve various functions, including **observing usage metrics**, **retrieving data from files or APIs**, or **executing transformations and calculations** on existing input data. A common example is a plugin that takes CPU utilisation as an input and produces an estimate of energy consumption as its output.

The Impact Framework boasts a growing ecosystem of plugins. It includes a **standard library of built-in plugins**, which are developed and maintained by the IF core team and cover many common operations such as arithmetic calculations, file input/output, and data manipulation. Beyond the built-in set, IF also encourages and supports **community-developed plugins**, which can address a wider range of specific needs, environments, and use cases. To facilitate the discovery and use of these community contributions, the **IF Explorer website** serves as a central repository where users can find and potentially contribute their own plugins.

To ensure interoperability and ease of use, the Impact Framework champions the idea of a **standard interface for all plugins**. The goal is that plugins, regardless of their specific function, should adhere to a common way of receiving inputs and providing outputs. This standardisation would greatly simplify the process of integrating different plugins into a pipeline, swapping them out for alternatives, upgrading them, and even comparing their accuracy and precision. Ultimately, this focus on a modular, plugin-based architecture aims to foster a large and vibrant ecosystem around software environmental impact measurement. For a detailed list and explanation of plugins, see the **Plugins** reference.

## Pipelines and the Process of Induction

Within the Impact Framework, a **pipeline** represents a **chain of plugins that are executed sequentially** on the input data associated with a particular component in the manifest file's tree. The input data flows through this sequence of plugins, with **each plugin performing its defined operation and typically adding a new key-value pair to the `inputs` array or updating the value of an existing entry**. This sequential processing allows for the creation of sophisticated workflows where the output of one plugin serves as the input for the next, enabling complex calculations and transformations.

The entire process of **taking an initial observation and converting it into a final environmental impact metric through this ordered series of plugins is known as induction**. Each plugin in the pipeline contributes a step in this inductive journey, moving from raw data towards a quantified impact. For instance, a pipeline might start with a plugin that retrieves CPU utilisation data, followed by a plugin that estimates energy consumption based on this utilisation, and finally a plugin that calculates carbon emissions from the energy figure. Pipelines are defined under the `pipeline` key within each component's specification in the manifest file. The order in which the plugins are listed in the `compute` section of the pipeline is crucial, as it dictates the flow of data and the sequence of transformations. More details on pipeline construction can be found in the **Pipelines** documentation.

## Deeper Dive into Context and Tree Structure

As mentioned earlier, the manifest file's structure is critical to how Impact Framework operates. The **context** and the **tree** serve distinct but complementary roles in defining and executing an environmental impact assessment.

The **context**, residing at the top of the manifest, provides the overarching settings and information for the entire process.

*   **Metadata** (`name`, `description`, `tags`) offers a way to identify and categorise the manifest file, providing essential context about the study being conducted.
*   The **`initialize` section** is where all the **plugins** that will be used within the manifest are declared and configured. This section is crucial as it makes the specified plugins available for use in the pipelines defined within the tree.
*   The **`execution` section**, automatically generated upon running the manifest, provides a snapshot of the runtime environment, including the command used to execute IF, the versions of IF and Node.js, the operating system, and any dependencies. This information is invaluable for debugging and ensuring the reproducibility of results.
*   The **`explain` section**, also auto-generated, details the metadata associated with the parameters of the plugins used in the manifest. This can include descriptions of the input and output parameters, their units, and aggregation methods.

The **tree** section, the second major part of the manifest, focuses on describing the system being analysed and the data associated with its components.

*   The tree is a **hierarchical structure** where the root represents the overall application or system, and its **children are individual components**. These components can be further nested to reflect the system's architecture in detail.
*   Each **component** within the tree can have its own **`pipeline`**, which specifies the sequence of **`observe`**, **`regroup`**, and **`compute`** phases for processing data. The `compute` phase is where the main plugin execution occurs.
*   The **`inputs`** field within each component holds an **array of observations**, representing time-series data relevant to that specific part of the system. Each observation typically includes a `timestamp` and a `duration`, along with the measured metrics.
*   The **`defaults`** field allows for the specification of **fallback values** for input parameters. If a particular observation in the `inputs` array is missing a value for a parameter that has a default specified, IF will use the default value instead. This can be useful for handling intermittent data availability or for setting constant values across all observations.

Refer to the **Manifest File** structure for a complete overview.

## Harnessing the Impact Engine (CLI)

The **`if-run` command-line tool**, part of the Impact Engine (CLI), serves as the primary interface for **executing Impact Framework manifest files**. It acts as the portal through which users interact with the framework, taking a manifest file as input and processing it to calculate environmental impacts. The most fundamental option for `if-run` is **`--manifest` or its alias `-m`**, which is **required** and specifies the **path to the input manifest file** that you wish to execute. Without a valid manifest file path, IF has nothing to process.

The `if-run` tool also offers several other useful options:

*   **`--output` or `-o` (optional):** This allows you to specify a **path to a file where the results of the manifest execution will be saved**. The output is typically in YAML format, representing the original manifest enriched with execution details and the results of the plugin pipelines.
*   **`--no-output` or `-n` (optional):** This option enables you to **suppress the output from being displayed in the console**, which can be useful for cleaner execution logs, especially for large manifests.
*   **`--help` or `-h`:** Prints out comprehensive **help instructions** detailing the available options and usage of `if-run`.
*   **`--debug`:** Enables **detailed execution logs**, providing more information about the framework's operation, which can be invaluable for identifying and resolving issues during manifest execution.
*   **`--append`:** Allows you to **re-run an already-computed manifest and append new values to the existing output data**, rather than overwriting it.
*   **`--observe`:** Instructs IF to run **only the `observe` phases** of the manifest execution. Plugins in the `observe` phase are designed to generate input data.
*   **`--regroup`:** Tells IF to execute **only the `regroup` phases**, which reorganise existing input data based on specified keys in the manifest.
*   **`--compute`:** Directs IF to run **only the `compute` phases**, where the plugins in the pipeline operate on the input data to generate output data and calculate impacts.

Impact Framework employs a **phased execution** model, separating the manifest processing into distinct stages: `observe`, `regroup`, and `compute`. While `if-run` by default executes all three phases sequentially, the ability to run these phases individually using the command-line flags offers greater flexibility and efficiency, allowing users to avoid unnecessary re-computation of parts of a manifest. For comprehensive information on CLI usage, consult the **Impact Engine (CLI)** documentation.

## Visualizing and Interpreting Results with the Visualizer

The **Impact Framework visualizer** is a valuable **web-based tool** designed to help users **view and explore the results** of computed manifest files in an aesthetic and accessible way. Instead of sifting through raw YAML data, users can utilise the visualizer to gain immediate insights into the environmental impacts of their software. By uploading or providing a link to a computed manifest file, the visualizer renders the impact data in intuitive formats, such as **pie charts that break down total carbon emissions by individual components** of the system (e.g., CPU, Memory, Storage, Network). This visual representation allows users to quickly identify which parts of their software stack contribute the most to the overall environmental footprint.

A key feature of the visualizer is the ability to **switch between different metrics**, most notably between **total carbon emissions (in gCO2e)** and the **Software Carbon Intensity (SCI)** score (expressed as gCO2e per functional unit, such as per visit). The SCI provides a measure of the carbon efficiency of the software relative to its usage. Below the primary visualisation, the visualizer typically presents a **Component Breakdown table**, which provides the **numerical values** corresponding to each component displayed in the pie chart, offering a more precise view of the data.

Furthermore, the visualizer enables a deeper level of investigation. By **clicking on segments of the pie chart**, users can often drill down into **sub-components**, revealing how the emissions of a larger component are distributed among its constituent parts. For components without further sub-levels, clicking on a segment usually triggers a **flyout panel**. This flyout is particularly informative as it displays the **raw input data (observations)** that were used in the calculations for that specific component, as well as the **pipeline of operations (the sequence of plugins)** that were executed on this data to arrive at the reported carbon and SCI values. This direct view of the data and processing steps enhances transparency and understanding of how the impact metrics were derived. Explore the **Quick Start** guide for visualizer usage.

## Deciphering Software Carbon Intensity (SCI)

**Software Carbon Intensity (SCI)** is a crucial metric within the realm of green software, designed to provide a standardised way of understanding the **carbon efficiency of software applications**. As defined by the specification, the SCI is calculated using the formula: **SCI = (E \* I + M) / R**. Here's a breakdown of each component:

*   **E (Energy consumed by software in kWh):** This represents the **operational energy** used by the software during a specific period. This energy consumption is often estimated from various observations like CPU utilisation, memory usage, and network traffic, processed through energy models.
*   **I (Carbon emitted per kWh of energy, gCO2/kWh):** This is the **carbon intensity** of the energy source powering the software's operation. It reflects the amount of carbon dioxide equivalent emitted for each unit of electricity produced. This value can vary significantly based on the geographic location and the time at which the energy is consumed, depending on the mix of energy sources in the grid (e.g., fossil fuels, renewables).
*   **M (Carbon emitted through the hardware that the software is running on):** This represents the **embodied carbon** associated with the hardware infrastructure on which the software operates. Embodied carbon accounts for the greenhouse gases emitted during the manufacturing, transportation, use, and disposal of the hardware components. Estimating embodied carbon can be complex and often relies on lifecycle assessments or models.
*   **R (Functional Unit; this is how software scales, for example per user or per device):** The functional unit is a **measure of the software's utility or the service it provides**. It allows the SCI to be expressed as a rate of carbon emission per unit of functionality, such as grams of CO2 equivalent per user, per request, per visit, or per transaction. The choice of a sensible functional unit is critical for making meaningful comparisons and tracking improvements in carbon efficiency as the software scales.

The "per R" aspect is what makes the SCI a versatile tool applicable across different software domains, use cases, and scales. By normalising the carbon impact against a measure of the software's function, the SCI facilitates comparisons between different versions of the same software or even between different applications providing similar functionalities. The SCI is also under development as an ISO standard. For a deeper dive into SCI, refer to resources on Software Carbon Intensity, such as the workshop materials which discuss it in detail.

## The Mechanics of Aggregation

**Aggregation** within the Impact Framework is the essential process of **summarising a set of metrics** to provide a more holistic view of the environmental impact. IF supports two primary types of aggregation: **time series aggregation (also known as horizontal aggregation)** and **tree aggregation (also known as vertical aggregation)**.

*   **Time series (horizontal) aggregation** focuses on taking a **time series of metric values for a single component and condensing it down into a single number** that represents the entire observation period. For example, if you have a time series of hourly energy consumption for a server over a 24-hour period, time series aggregation could sum these values to provide the total energy consumed by that server for the day. The specific method of aggregation (e.g., sum, average, min, max) can depend on the nature of the metric being aggregated and the insight you wish to gain. The result of horizontal aggregation is typically added as a new field called `aggregated` to the node whose time series was processed.

*   **Tree (vertical) aggregation** operates across the **hierarchical structure of components within the manifest file's tree**. Where multiple child components under a parent node have their own time series data for a particular metric, tree aggregation **combines these time series together into a single summary time series** that is then associated with the parent node. This aggregation happens **element-wise** across the child components' time series for each timestep. For instance, if a web application has multiple front-end server components, their individual hourly carbon emissions time series could be aggregated (e.g., summed) to produce a single hourly carbon emissions time series representing the total impact of the front-end tier. The result of vertical aggregation is often a new array of output observations named `outputs` at the parent level, containing the aggregated metrics along with timestamps and durations.

The Impact Framework's **`aggregate` feature is built-in**, meaning you do not need to explicitly initialise it as a plugin. To configure aggregation, you simply add a small `aggregate` section to your manifest file. This configuration allows you to specify the **`metrics`** (an array of metric names, like 'carbon' or 'energy') that you want to aggregate and the **`type`** of aggregation to perform, which can be `time`, `component`, or `both`. The choice of aggregation method (e.g., sum, average) is often implicitly determined by the metric itself or can be influenced by the type of plugin used in the pipeline. Understanding aggregation is crucial for gaining a high-level overview of environmental impacts across different parts of your software system and over time. For detailed configuration options, see the **Aggregation** documentation.

## Leveraging Exhaust Scripts for Diverse Output Formats

While the Impact Framework's primary output format for computed manifest files is YAML, there are often scenarios where users need to present or utilise this data in other formats, such as CSV for spreadsheets or integration with other tools. This is where **exhaust scripts** come into play. These are **independent scripts that can be run separately from IF itself** and are designed to **take an executed manifest file (the YAML output containing the `outputs` section) as their input**. The purpose of an exhaust script is to **parse this YAML data and reformat it into some other desired representation**.

The Impact Framework **bundles a built-in exhaust script called `if-csv`**. This script allows users to pass in YAML or YML files (typically those created using the `if-run` command) and save the extracted data in **CSV format**. When using `if-csv`, you need to **define the specific parameters you wish to export** from the YAML file, such as 'energy' or 'carbon'. The script then extracts these parameters from the relevant parts of the computed manifest (usually from the `outputs` sections of the components) and structures them into a CSV file, with options to specify the output file path.

Beyond the built-in `if-csv` script, the Impact Framework is designed to be extensible in this area. If users require output in other data formats beyond CSV, they have the **flexibility to create their own custom exhaust scripts**. These scripts can be written in any language that can parse YAML and output the desired format. This allows for seamless integration of IF's impact assessment data with a wide range of reporting tools, databases, and analysis pipelines. Learn more about creating and using exhaust scripts in the **Exhaust scripts** section.

## Guiding Principles: The Design Philosophy

The development and evolution of the Impact Framework are guided by a set of core **design philosophies** that underpin its functionality, usability, and community engagement. These principles ensure that IF remains a robust, transparent, and valuable tool for measuring and mitigating software's environmental impact. The key tenets of this design philosophy include:

*   **Transparency:** This principle emphasizes the importance of making the entire environmental impact calculation process open and understandable. The **manifest file** is central to this, as it explicitly **defines all the context for a calculation**, including the application's architecture, the observation period, the pipeline of calculations, and the environmental impacts being tracked. This single document can be executed to generate impact values, providing unparalleled transparency as anyone can read and understand the methodology.
*   **Verifiability:** Closely linked to transparency, verifiability ensures that an organisation's impact calculations can be independently checked and confirmed. Because **everything needed to perform a calculation is contained within the manifest file**, anyone with the manifest and the lightweight Impact Framework command-line tool can **re-execute it and verify the reported impact values**. This also allows for experimentation by swapping out different plugins to understand their influence.
*   **Flexibility:** The Impact Framework aims to impose the **minimum of constraints** on its users, balancing helpful standards that ensure plugin interoperability with the freedom for expression and creativity in defining and measuring impacts. The real power of IF comes from the community's ability to experiment with plugins and measurement methodologies. The manifest file serves as a foundation not only for reporting but also for forecasting, exploring optimisation strategies, and supporting research and business decision-making.
*   **Modularity:** IF is designed as a **minimal set of core features** that enable the processing of manifest files according to agreed principles. It provides a tool for processing manifests and a set of standards, allowing developers to create **plugins that perform specific tasks**, such as data retrieval from particular providers or applying specific calculations. This modularity fosters a **bottom-up, community-driven development model**, where anyone can build and share plugins.
*   **Neutrality:** Impact Framework strives to support **maximally decentralised plugin development**. It aims to empower anyone to build and use plugins for calculating their environmental impacts without gatekeeping what can be measured. The focus is on providing the minimal **protocol** required to support community plugin development and ensure a degree of safety and consistency in calculations. The goal is to see an organic and permissionless growth of the Impact Framework plugin ecosystem.

These principles collectively guide the development of Impact Framework, ensuring it remains a powerful, trustworthy, and adaptable tool for addressing the environmental challenges of software. These principles are further explained in the **Design philosophy** documentation.

## Managing Time Series Data with the Time Feature

In the context of environmental impact assessment, data often comes in the form of **time series**, where observations of various metrics are recorded at specific points in time with associated durations. The Impact Framework inherently works with time series data, as each **observation** within a component's `inputs` array includes a **`timestamp`** indicating the start time of the observation and a **`duration`** specifying the length of the observation period. The collection of these timestamped observations forms the time series for that particular component.

However, a manifest file can encompass numerous components, each potentially having its own time series data. These individual time series might **vary in their start and end times, their temporal resolution (frequency of observations), and may even contain gaps** where data is missing. This heterogeneity in time series can pose challenges for tasks such as aggregation, visualisation, and performing meaningful comparisons between different components.

To address these challenges, Impact Framework provides a built-in **`time-sync` feature**. This feature allows for the **synchronisation of time series across all the components within a manifest file's tree**. The `time-sync` feature takes a **global start time, end time, and a common interval (resolution)** as configuration. It then processes each component's time series to conform to this global temporal configuration. This process involves several key steps:

*   **Upsampling:** Each time series is first upsampled to a common base resolution (typically 1 second) to create a more granular foundation.
*   **Gap Filling:** Any discontinuities or gaps within a component's time series (periods where no data was recorded) are filled in with **"zero objects"**. These are observations with the same structure as the real data but with all usage metrics set to zero, effectively assuming no activity occurred during the missing periods.
*   **Start and End Time Alignment:** The `time-sync` feature compares the start and end times of each component's time series with the globally defined start and end times. If a component's data starts after the global start, the beginning of its time series is padded with "zero objects" to align the start times. Conversely, if a component's data starts before the global start, the initial observations are trimmed. A similar trimming logic is applied to the end times to ensure all time series end at the global end time.
*   **Batching to Interval:** Once the start and end times are synchronised and any discontinuities are handled, the upsampled time series are then **batched together into time bins** according to the globally specified `interval`. This ensures that all synchronised time series have an identical temporal resolution.

The `time-sync` feature can be configured within a component's `pipeline` in the manifest file. While it can be placed at various points in the pipeline, it is generally **recommended to position `time-sync` as the first plugin** whenever possible. This is because operating on fewer parameters earlier in the pipeline can improve efficiency, and it ensures that all subsequent plugins receive consistently synchronised time series data. However, specific use cases might necessitate placing `time-sync` at a different point in the pipeline, and users should be aware of the potential impact this might have on the final results. The padding with zero values can also be toggled off in the manifest if a strict requirement for continuous, originally provided time series exists.

By yielding synchronised time series across all components, the `time-sync` feature greatly facilitates visualisation, intercomparison, and is a prerequisite for the framework's aggregation functionality. For more details, refer to the **Time** documentation.

## Organising Data with the Regroup Feature

The **`regroup` feature** in Impact Framework provides a powerful mechanism for **reorganising the structure of the component tree based on keys present in the observation data**. This allows users to dynamically restructure their analysis based on various properties of their application's components, offering enhanced flexibility in how impacts are viewed and aggregated.

Typically, when data is initially ingested into Impact Framework (for example, from an importer plugin that pulls metrics from a cloud service API), it might exist as a **flat array of observations** within a single component. Each observation in this array could contain various fields, such as a timestamp, duration, instance type, cloud region, CPU utilisation, etc.. However, for analysis and understanding, it is often beneficial to **organise this data into a hierarchical structure based on specific attributes**, such as grouping all observations for a particular instance type or within a specific cloud region under separate child components.

The `regroup` feature facilitates this restructuring. It is **not a plugin** but rather a **core functionality of IF** that is executed during the manifest processing when you run `if-run` or specifically `if-run --regroup` if the regroup configuration is present. To utilise `regroup`, you simply need to **provide the keys (the names of the fields in your observations) that you want to regroup by in the `regroup` pipeline** configuration at the desired node level in your manifest's tree.

For example, if your initial `inputs` array contains observations with fields like `cloud-region` and `instance-type`, you can configure `regroup` to reorganise the tree first by `cloud-region` and then by `instance-type`. This would result in a new tree structure where the original component now has child components for each unique `cloud-region` found in the data. Each of these region-based child components would then further have their own child components for each unique `instance-type` within that region, and the corresponding observations would be moved into the `inputs` array of these newly created, more granular components.

The `regroup` configuration is specified at the node level in the `pipeline` section using the `regroup` keyword, followed by a list of the keys to regroup by. The order in which the keys are listed determines the hierarchy of the regrouped tree. This feature allows for dynamic and flexible organisation of observation data, making it easier to analyse impacts based on different dimensions of your software deployment and facilitating more targeted insights. For more details on its usage, refer to the **Regroup** documentation.

## Practical Application: Hands-on with Impact Framework

The concepts discussed so far come to life through the practical application of Impact Framework. The **"Quick Start - Your First SCI Calculation"** section of the Impact Framework Course Outline provides a hands-on introduction to these ideas. It guides new users through the process of exploring a pre-built manifest file using the **visualizer**, allowing them to see the breakdown of carbon emissions and SCI scores for a hypothetical website. Users can examine the **observations** that feed these calculations and the **pipeline of operations (models)** used to generate the impacts by interacting with the visualizer's flyout panels.

The course then transitions to running Impact Framework locally via the **command line**. Participants are guided through the installation process and the execution of the same manifest file they explored in the visualizer, using the **`if-run` command**. They learn how to view the output, which includes the original manifest enriched with **`execution` details and the calculated `outputs`** for each component.

A crucial part of the hands-on experience is understanding the **structure of the manifest file**, differentiating between the **context** (metadata and plugin definitions) and the **tree** (system architecture, pipelines, and input data). The course highlights the role of **plugins** as self-contained code units and **pipelines** as the sequential execution of these plugins to transform observations into impacts (a process termed **induction**).

Finally, the practical exercises involve **editing the manifest file** – for instance, modifying an input value like CPU utilisation – and then **re-running the manifest** to observe how this change affects the final carbon emissions and SCI score in the visualizer. This direct manipulation and observation reinforce the core concepts and demonstrate the power and responsiveness of the Impact Framework. The "Quick Start" aims to make these abstract ideas concrete and empower users to begin their journey with software carbon measurement.

## Building Custom Solutions: Plugin Development

A key aspect of the Impact Framework's flexibility and extensibility lies in its support for **custom plugin development**. As highlighted in the YouTube workshop transcript and the "Plugins" documentation, the framework is designed to be built upon, with plugins serving as the fundamental units of functionality. Because no single plugin can cater to all possible impacts, scenarios, and data sources, the ability for users to **create their own plugins** is essential for tailoring Impact Framework to specific needs.

The workshop provides a practical demonstration of building a simple plugin from scratch using JavaScript. This involves creating a plugin folder, initialising it as a Node.js package using `npm init`, and creating a JavaScript file (typically `index.js`) where the plugin code resides. A plugin in IF is essentially a function that, when initialised, can receive global configuration and must return an object containing metadata and an `execute` function. The `execute` function is where the core logic of the plugin resides; it receives the input data (observations) and any node-level configuration, performs its operations, and returns the modified or enriched data.

To make a locally developed plugin available for use in a manifest file, the workshop demonstrates the use of `npm link` within the plugin's directory. This creates a symbolic link, allowing the plugin to be linked into the Impact Framework project (especially if you have cloned the IF repository locally, which is recommended for plugin development) using `npm link <plugin-name>` in the main IF directory or your project directory. Once linked, the custom plugin can be declared in the `initialize` section of the manifest file, specifying its path (which will now correspond to the linked package name) and method. Subsequently, this plugin can be used within the `compute` pipeline of any component in the manifest tree.

This capability for plugin development empowers users to integrate custom data sources, implement specific models or calculations, and extend the functionality of Impact Framework to address their unique requirements in measuring and reducing software's environmental impact. The growing library of both standard and community plugins contributes to the strength and versatility of the Impact Framework ecosystem.


# Impact Framework: Core Concepts Summary

The Impact Framework (IF) is an **open-source tool** designed to **calculate and share the environmental impacts of software**. It aims to make the measurement of impacts like carbon emissions, water usage, and energy consumption more accessible and transparent. IF operates through **manifest files**, which are central to its functionality. For more information, see the **Welcome to Impact Framework** page at [https://if.greensoftware.foundation/](https://if.greensoftware.foundation/).

## Manifest Files: The Heart of IF

**Manifest files** are written in **YAML format** and serve as **executable audits**. They contain all the **necessary configurations**, define the **application architecture**, hold the **input data**, and specify the **pipeline of calculations**. These files are **shareable, portable, and human-readable**, allowing for verifiability of environmental impact calculations. The structure of a manifest file includes a **context** section and a **tree** section. For more information, refer to the **Manifest File** documentation at [https://if.greensoftware.foundation/docs/manifest-file](https://if.greensoftware.foundation/docs/manifest-file).

## Observations and Impacts

**Observations** are the **raw measurements or data points collected about software**. These can include metrics like CPU utilisation, memory usage, network traffic, and more. **Impacts** are the **environmental consequences calculated from these observations**, such as carbon emissions (gCO2e) or energy consumption (kWh). The process of converting observations into impacts is facilitated by plugins and pipelines. Consult the **Introduction** documentation for a broader understanding at [https://if.greensoftware.foundation/docs/introduction](https://if.greensoftware.foundation/docs/introduction).

## Plugins: The Building Blocks

**Plugins** are **self-contained units of code** that perform specific tasks within IF. They can **observe metrics, grab data, or execute transformations and calculations** on input data. IF has a **standard library of built-in plugins** and also supports **community-developed plugins**. These plugins are chained together in **pipelines** to perform complex environmental impact assessments. For a detailed list and explanation of plugins, see the **Plugins** reference at [https://if.greensoftware.foundation/docs/plugins](https://if.greensoftware.foundation/docs/plugins).

## Pipelines and Induction

A **pipeline** is a **sequence of plugins** that operate in order over the input data. Data flows through the pipeline, with each plugin adding or updating information. The process of taking an observation and converting it into an impact through this series of plugins is known as **induction**. Pipelines are defined within each component in the manifest file's tree. More details on pipeline construction can be found in the **Pipelines** documentation at [https://if.greensoftware.foundation/docs/pipelines](https://if.greensoftware.foundation/docs/pipelines).

## Context and Tree: Manifest Structure

The manifest file is broadly divided into the **context** and the **tree**. The **context** (everything above the `tree` keyword) includes **metadata** about the manifest (name, description, tags) and the **`initialize` section** where **plugins are defined and configured**. The **tree** section describes the **architecture of the system being measured**, organised hierarchically into **components**. Each component can have its own pipeline, input data (`inputs`), and default values (`defaults`). Refer to the **Manifest File** structure for a complete overview at [https://if.greensoftware.foundation/docs/manifest-file](https://if.greensoftware.foundation/docs/manifest-file).

## Impact Engine (CLI)

The **`if-run` command-line tool** is used to **execute Impact Framework manifest files**. It takes a manifest file as input and can output the results to the console or a specified file using the `--output` flag. The CLI also supports **phased execution** using flags like `--observe`, `--regroup`, and `--compute` to run specific stages of the manifest processing. For comprehensive information on CLI usage, consult the **Impact Engine (CLI)** documentation at [https://if.greensoftware.foundation/docs/impact-engine](https://if.greensoftware.foundation/docs/impact-engine).

## Visualizer: Exploring Results

The **Impact Framework visualizer** is a web-based tool that allows users to **view and explore the results of computed manifest files**. Users can upload or link to a manifest file to see visual representations of the environmental impacts, such as pie charts breaking down emissions by component. The visualizer also displays **Software Carbon Intensity (SCI)** scores and allows users to inspect the **observations and pipelines** for individual components. Explore the **Quick Start** guide for visualizer usage at [https://if.greensoftware.foundation/docs/quick-start](https://if.greensoftware.foundation/docs/quick-start).

## Software Carbon Intensity (SCI)

**Software Carbon Intensity (SCI)** is a metric used to understand the **carbon efficiency of software**. It is typically expressed as **grams of CO2 equivalent per functional unit (e.g., gCO2e/visit)**. The SCI calculation considers the **energy consumed**, the **carbon intensity of the energy source**, and the **functional unit** of the software. The Impact Framework provides tools and plugins for calculating SCI. For a deeper dive into SCI, refer to resources on Software Carbon Intensity, such as the workshop materials which discuss it in detail.

## Aggregation: Summarizing Metrics

**Aggregation** is the process of **summarizing a set of metrics** within Impact Framework. IF supports two main types of aggregation: **time series (horizontal) aggregation**, which condenses a time series into a single value, and **tree (vertical) aggregation**, which aggregates metrics across components in a hierarchical structure. Aggregation is configured in the manifest file and is crucial for understanding overall impacts. For detailed configuration options, see the **Aggregation** documentation at [https://if.greensoftware.foundation/docs/aggregation](https://if.greensoftware.foundation/docs/aggregation).

## Exhaust Scripts: Outputting in Different Formats

**Exhaust scripts** are independent scripts that take the **YAML output of Impact Framework** and **reformat it into other representations**, such as CSV. IF includes a built-in `if-csv` exhaust script, and users can create their own for different data formats. These scripts facilitate the use of IF data in other tools and reporting systems. Learn more about creating and using exhaust scripts in the **Exhaust scripts** section at [https://if.greensoftware.foundation/docs/exhaust-scripts](https://if.greensoftware.foundation/docs/exhaust-scripts).

## Design Philosophy: Core Principles

The design of Impact Framework is guided by several core principles, including **transparency**, **verifiability**, **flexibility**, **modularity**, and **neutrality**. **Transparency** is achieved through the manifest file, which details the entire calculation. **Verifiability** allows anyone to re-execute the manifest and confirm the results. **Flexibility** ensures IF can be used for various scenarios. **Modularity** enables community-driven plugin development. **Neutrality** means IF doesn't gatekeep what can be measured. These principles are further explained in the **Design philosophy** documentation at [https://if.greensoftware.foundation/docs/design-philosophy](https://if.greensoftware.foundation/docs/design-philosophy).

By understanding these core concepts, users can effectively leverage the Impact Framework to measure, analyse, and ultimately reduce the environmental impact of their software applications. Remember to consult the detailed documentation for each concept within the Impact Framework resources for more in-depth information.
****