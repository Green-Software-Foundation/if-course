# Proxy Measurements

In the previous example, we calculated carbon emissions based on an observation of energy usage from a server’s CPU. However, servers include other components that also produce emissions, such as memory.

In this next example, you'll add a **memory component** to the server to create a more complete picture of the overall carbon emissions. You'll work with a **single component** (the server) and chain **two plugins** together, providing an opportunity to become familiar and comfortable with building pipelines from multiple plugins.

## IOMI

As introduced in the previous module, the standard development process involves these 4 steps.

1. **Impacts**: What impact(s) do you want to compute?
2. **Observations**: What observation(s) can you gather?
3. **Methodology**: What methodology will you select for inducing the observation(s), into the impact(s)?
4. **Implementation**: Implementation of the methodology as a pipeline of plugins.

## Impact

Nothing changes here, we are still interested in computing the `carbon` impact of our server.

## Observation

You look into what metrics are exposed via the cloud provider’s monitor API and find that **all** you have available is `memory utilisation`. You will try to use this to **work out your carbon emissions for one hour.**

You make a request to the monitor API, configured to return the average memory utilisation across the last hour. It returns a **value of `55%`**.

## Methodology

Now, you have to do a little research to determine what to do with that memory untilization. **Memory utilisation is a proxy measurement for energy consumption** which is in itself a proxy for the metric you really want, which is carbon emissions. So you have to search the literature, look for models that have been proposed elsewhere for turning memory utilisation into energy or carbon.

[**Cloud Carbon Footprint**](https://www.cloudcarbonfootprint.org/) proposes a **coefficient for converting memory utilisation into energy**, which gets you one step closer to your goal.

They suggest that multiplying memory utilisation in gigabytes by a `0.000392 kWh/GBh` is appropriate for a first-order estimate of the energy consumption due to memory. This value is derived from averaging the values proposed by two industry power models.

So, in order to apply this coefficient, you first have to express your memory utilisation in GB. What you have from the API is a percentage. You need to know the total available memory for your instance. 

You can retrieve this information from several sources - you can usually look in your cloud dashboard to find the specs for your virtual machine, or you can look up the instance name in the provider’s documentation or you can refer to [our dataset of instance metadata](https://github.com/Green-Software-Foundation/if-data/blob/main/cloud-metdata-azure-instances.csv)

Let’s say your instance is an `Azure Standard A2m_v2`. Our dataset shows that it has 16 GB memory. So your memory utilisation in gigabytes for the past hour is

```mathematica
16 (GB) * 0.55 = 8.8 GB.
```

Now you can apply your coefficient to yield an energy value in kWh.

```mathematica
8.8 (GB) * 0.000392 (kWh/GBh) = 0.003432 kWh
```

Now you can multiply the energy in kWh by the carbon intensity of the energy being used to power your job. Assuming you are running this in the UK, the average carbon intensity is around `163 gCO2e/kWh`, so to get carbon emissions for your virtual machine’s memory utilisation, you can do:

```mathematica
0.003432 (kWh) * 163 (gCO2e/kWh) = 0.559 g Co2e
```

So, in the past hour the VM has **emitted** **`0.559 g CO2e`** due to memory.

Next up let's implemennt this methodology to our manifest file.

## Implementation

So, comparing that to the previous exercise, there is an additional step. Rather than having `energy` given to you, you have to apply another model to get `energy` from memory utilisation.

The output from one model (**memory utilisation to energy**) is the input to the next (**energy to carbon**).

We are continuing to add to the IMP file we created in the previous section:

```yaml
name: energy-to-carbon
description: minimal demo
tags:
initialize:
  plugins:
    carbon-from-energy:
      method: Coefficient
      path: "builtin"
      config:
        input-parameter: energy
        coefficient: 163
        output-parameter: carbon
tree:
  children:
    server-1:
      defaults:
      pipeline:
        compute:
          - carbon-from-energy      
      inputs:
        - timestamp: 2023-08-06T00:00
          duration: 3600
          cpu-energy: 0.05  # <1>
```
- <1>: To avoid a clash and make the intention clearer, we renamed the original `energy` to `cpu-energy`.

We first want to add another `Coefficient` plugin instance to represent the model to estimate energy from memory-utilization, add the below to the plugin -> initialize section in the IMP.

```yaml
energy-from-memory-utilization:         # <1>
  method: Coefficient
  path: "builtin"
  config:
    input-parameter: memory-utilization # <2>
    coefficient: 0.00039                # <3>
    output-parameter: memory-energy     # <4>
```
- <1>: The name of the plugin instance.
- <2>: This instance of the `Coefficient` plugin reads `memory-utilization` from the input observation.
- <3>: The coefficient we reasearched in the methodology section above.
- <4>: The plugin will output `memory-energy`, the result of multiplying `memory-utilization` by `0.00039`

There is one more step we need to compelte this manifest. The energy from the cpu is now `cpu-energy` and `energy-from-memory-utilization` will output `memory-energy` but `carbon-from-energy` expects `energy` as an input.

We will need to sum both `memory-energy` and `cpu-energy` into `energy`. To do that we will use another plugin from the standard library `Sum`. Again, let's first configure this plugin in the initialise section, like so:


```yaml
sum-energy: 
  path: "builtin" 
  method: Sum                 # <1>	                 
  config:
    input-parameters:         # <2>	
      - memory-energy
      - cpu-energy
    output-parameter: energy  # <3>	  
```
- <1>: The plugin to load from the standard library, `Sum` in this case.
- <2>: The array of observation parameters you want to sum up to a total.
- <3>: The parameter name you want to output to, in this case `energy`.

The full IMP will now look something like so:

```yaml
name: server-carbon
description: minimal demo
tags:
initialize:
  plugins:
    carbon-from-energy:
      method: Coefficient
      path: "builtin"
      config:
        input-parameter: energy
        coefficient: 163
        output-parameter: carbon
    energy-from-memory-utilization:        
      method: Coefficient
      path: "builtin"
      config:
        input-parameter: memory-utilization 
        coefficient: 0.00039                
        output-parameter: memory-energy     
    sum-energy: 
      path: "builtin" 
      method: Sum                                
      config:
        input-parameters:         
          - memory-energy
          - cpu-energy
        output-parameter: energy  
tree:
  children:
    server-1:
      defaults:
      pipeline:
        compute:
          - energy-from-memory-utilization  # <1>
          - sum-energy                      # <2>
          - carbon-from-energy   
      inputs:
        - timestamp: 2023-08-06T00:00
          duration: 3600
          cpu-energy: 0.05                 
          memory-utilization: 8.8          # <3>
```
- <1>: We added the new model `energy-from-memory-utilization` to the pipeline. In this case we added it as the first item, since the second model in the pipeline, `sum-energy`, depends on the output of this model.
- <2>: We also added `sum-energy` to the pipline to aggregate both `memory-energy` and `cpu-energy` into `energy`
- <3>: We added the observation 8.8 Gb as `memory-utilization`.

## Computation

Now you can run the IMP using:

```yaml
if-run -m imp.yml -o out.yml
```

The output manifest file should look something like so:

```yaml
**➜ if-run -m imp.yml -o out.yml**

# start
name: server-carbon
description: minimal demo
tags: null
initialize:
  plugins:
    memory-to-energy-component-1:
      path: builtin
      method: Multiply
      config:
        input-parameters:
          - memory-utilization
          - memory-coefficient
        output-parameter: energy
    energy-to-carbon-component-1:
      path: builtin
      method: Multiply
      config:
        input-parameters:
          - energy
          - carbon-intensity
        output-parameter: carbon
execution:
  command: >-
    /Users/russell/.nvm/versions/node/v22.13.1/bin/node /usr/local/bin/if-run -m
    imp.yml
  environment:
    ...
  status: success
tree:
  children:
    component-1:
      defaults: null
      pipeline:
        compute:
          - memory-to-energy-component-1
          - energy-to-carbon-component-1
      inputs:
        - timestamp: 2023-08-06T00:00
          duration: 3600
          memory-utilization: 8.8
          memory-coefficient: 0.00039
          carbon-intensity: 163
      **outputs:**
        - timestamp: 2023-08-06T00:00
          duration: 3600
          memory-utilization: 8.8
          memory-coefficient: 0.00039
          carbon-intensity: 163
          energy: 0.003432
          **carbon: 0.559416**

# end
```

- <1>: TODO explain the above.

## Conclusion

In this module, we learned how to handle **proxy measurements** within the Impact Framework by converting indirect metrics—like memory utilization—into meaningful carbon emissions data. 

By chaining multiple plugins together, we demonstrated how to create sophisticated pipelines that first convert memory utilization to energy, and then energy to carbon emissions. 

This methodology highlights the flexibility and modularity of IMP files, making your impact assessments both transparent and auditable.

Next, you can further expand on this approach by incorporating additional components or plugins, enabling an even more comprehensive understanding of your software’s environmental footprint.

## Quiz

1. **What is a "proxy measurement" in the context of the Impact Framework?**
   - A) Direct measurement of energy consumption
   - B) An indirect measurement used to estimate energy or carbon emissions
   - C) Measurement of carbon intensity directly from the source
   - D) Measurement of CPU energy only

   **Answer:** B

2. **In our example, why did we multiply memory utilization by the coefficient `0.000392 kWh/GBh`?**
   - A) To calculate total memory used
   - B) To directly compute carbon emissions
   - C) To estimate energy consumption from memory usage
   - D) To convert CPU energy into memory energy

   **Answer:** C

3. **Which standard plugin did we use to combine `cpu-energy` and `memory-energy` into a single `energy` value?**
   - A) Coefficient
   - B) Sum
   - C) Average
   - D) Multiply

   **Answer:** B

4. **If your instance has 32 GB of memory and the API reports memory utilization as 50%, what is the memory usage in GB?**
   - A) 8 GB
   - B) 12 GB
   - C) 16 GB
   - D) 32 GB

   **Answer:** C

5. **Why do we include the pipeline and methodology in the IMP file?**
   - A) To increase computational speed
   - B) To make the impact calculations transparent, verifiable, and auditable
   - C) To reduce the total number of plugins needed
   - D) To eliminate the need for external documentation

   **Answer:** B