# SCI Walkthrough - Methodology & Implementation - Embodied Carbon

Let's revisit our dependency tree to see what we did and what's remaining.

â˜‘ï¸ sci
- âœ… operational-carbon
  - âœ… operational-energy
    - âœ… cpu-energy
      - ðŸ cpu-utilization(80)
      - ðŸ cloud-vendor(Microsoft Azure)
      - ðŸ cloud-instance-type(Standard_A2m_v2)
    - âœ… memory-energy
      - ðŸ memory-utilization(8)
  - âœ… carbon-intensity
    - ðŸ cloud-region(westeurope)
- â˜‘ï¸ embodied-carbon
    - ðŸ cloud-vendor(Microsoft Azure)
    - ðŸ cloud-instance-type(Standard_A2m_v2)
- â˜‘ï¸ functional-unit
  - ðŸ site-visits(550)

In this module we are going to work through the methodology for the embodied carbon impact dependency.

## `embodied-carbon`

### Methodology

Carbon is emitted when the hardware used to run an application is manufactured, and more will be emitted when the hardware is disposed of. This is the â€œembodiedâ€ or â€œembeddedâ€ carbon, represented by the symbol `M` in the `SCI` equation.

Calculating embodied emissions is perhaps the most **difficult** component to measure due to the lack of **open** data regarding the embodied emissions of hardware. They typically come from manufacturers conducting life cycle assessments for the products they sell and sharing the total embodied carbon in a data sheet. However, few manufacturers do this, and those that do tend to only do it for a subset of their products of those only a few publish the data for everyone to see. 

> [!IMPORTANT]
> If you work for a large enterprise organization you might be able to get access to this data from your suppliers. If they don't publish it openly, they do often release it to their suppliers under an NDA. We recommend reaching out to your sustainability department and seeing if you have access to embodied carbon values from your suppliers.

> [!IMPORTANT]
> If you have access to or can obtain better, more accurate data regarding the embodied carbon of your devices, we strongly recommend that you do so and **do not use** the above methodology. The methodology and underlying data sources are woefully incomplete since there is a deep lack of public disclosure here. If you work for a large organization, you might have the ability to request detailed embodied carbon values from your suppliers under a non-disclosure agreement. We strongly recommend you pursue that approach if you can and only use the above methodology as a fallback.

If you do not or cannot get access to this data, this means you often have to find analogs or models to estimate embodied carbon for hardware components.

A popular model for embodied carbon is the one published in https://medium.com/teads-engineering/building-an-aws-ec2-carbon-emissions-dataset-3f0fd76c98ac, which is also used by [Cloud Carbon Footprint.](https://www.cloudcarbonfootprint.org/docs/embodied-emissions) They define a minimal "baseline" rack server with a given embodied carbon value and then specify how much carbon to add to the baseline for each additional component your real server has.

**How this model works:** The baseline model starts with a minimal server configuration (typically 1 CPU, minimal memory, no storage) with a known embodied carbon value. For your actual server, you calculate the embodied carbon by taking this baseline value and adding incremental amounts for each additional component:
- Additional CPUs add X kg CO2e
- Each GB of memory adds Y kg CO2e
- Each SSD adds Z kg CO2e

The `SciEmbodied` plugin in Impact Framework implements this methodology, using coefficients derived from the Cloud Carbon Footprint model to automatically calculate embodied carbon based on your server specifications.

As you can imagine, the above model is poor, outdated and may lead to very inaccurate figures, however its big advantage is that if you have some generic data regarding your servers then you can estimate the embodied emissions.

### Implementation

#### Server Meta-Data

The CCF model, in order to estimate the embodied carbon of your server, needs to know several bits of information such as the number of vCPUs, amount of memory, and how many SSD drives, etc.

As you can see the model we are going to use needs some additional meta data about the server, including the total amount of memory, the number of vCPUs and the number of SSDs. The cloud instance dataset from the GSF already has some of this data so let's just adjust that plugin configuration to output some additional values.

The highlighted rows below are the lines we changed to output additional columns:

```yaml
cloud-instance-metadata:
  method: CSVLookup
  path: 'builtin'
  config:
    filepath: https://raw.githubusercontent.com/Green-Software-Foundation/if-course/refs/heads/main/src/cloud-metdata-azure-instances.csv
    query:
      instance-class: "cloud-instance"
    # highlight-start
    output: "*"
    # highlight-end
```        

> [!IMPORTANT]
> The GSF cloud instance dataset doesn't at the time of writing have good data regarding the number of SSDs for each server. Community contributions are welcome!

#### Embodied Model

The Impact Framework `builtins` has a plugin, `SciEmbodied`, for simplifying the application of the above methodology. You simply specify your hardware in your input data, and it calculates the embodied carbon using the Cloud Carbon Footprint model.

The plugin initialization is extremely simpleâ€”you do not have to provide any config data at all unless you want to override some default settings. You can simply add the following to your `initialize: plugins:` block:

```yaml
embodied-carbon:
  path: builtin
  method: SciEmbodied
```

The plugin does expect the inputs to be named differently to how we have named them, Impact Framework has a feature specifically for this purpose called mappings, let's configure it like so:

```yaml
embodied-carbon:
  path: builtin
  method: SciEmbodied
```

The `SciEmbodied` plugin uses the Cloud Carbon Footprint (CCF) model to estimate embodied carbon based on hardware specifications. It expects certain input parameters with specific names (like `vcpus`, `memory`, `ssd`).

Since we're already retrieving metadata from the `cloud-instance-metadata` plugin, that data will be available in our inputs. The `SciEmbodied` plugin will automatically use these values if they match the expected parameter names.

> [!NOTE]
> The `SciEmbodied` plugin expects parameters like `vcpus`, `memory` (in GB), and `ssd` (number of drives). If your cloud metadata uses different field names, you would need to use parameter mapping to rename them. The `cloud-instance-metadata` plugin with `output: "*"` will output all columns from the CSV, which should include these fields.

For example, if you were manually providing these values, you could add them to the defaults or inputs of a component like so:

```yaml
defaults:
  vcpus: 2
  memory: 16
  ssd: 1
```

With the configuration above, the `SciEmbodied` plugin will calculate the total embodied emissions for the server and add it to the output data using the parameter name `embodied-carbon`.

More details regarding the SciEmbodied model can be found [here](https://github.com/Green-Software-Foundation/if/blob/main/src/if-run/builtins/sci-embodied/README.md).



<!-- TODO: Complete this module. Needs:
1. Full manifest that adds SciEmbodied + cloud-instance-metadata (with output: "*") to the pipeline from Module 6c
2. Run output showing embodied-carbon in the outputs
3. The operational-carbon section below was removed as it was a stale copy from Module 6c and didn't include embodied carbon
-->