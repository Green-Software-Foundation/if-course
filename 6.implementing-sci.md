# SCI Walkthrough - Part 1

So far we have focussed on computing the impact `carbon`. In the previous module we learned about the `SCI` specification, in terms of Impact Framework `SCI` is an impact. 

In this module we will continue with our worked example but transform the impact from `carbon` to `sci`.

## IOMI

As should be fairly standard now, our process starts with **IOMI**.

1. **Impacts**: What impact(s) do you want to compute?
2. **Observations**: What observation(s) can you gather that *could* be induced to that impact?
3. **Methodology**: What methodology will you select for inducing the observation(s), into the impact(s)?
4. **Implementation**: Implementation of the methodology as a pipeline of plugins.

### Impacts

In this specific case this server is serving a website and the SCI score we want to calculate is Carbon per Visit.

As a reminder, the SCI score is calculated as follows:

```mathematica
SCI = (E * I + M) / R
```

- `E` is operational energy
- `I` is carbon intensity
- `M` is embodied carbon
- `R` is the functional unit, in this case `site-visits`

Read more https://sci-guide.greensoftware.foundation/

In the SCI specification `(E * I)` is often expressed as simply `O`, operational carbon, like so:

```mathematica
SCI = (O + M) / R
```

- `O` is operational carbon
- `M` is embodied carbon
- `R` is the functional unit.

So far all we have been computing is operational carbon. 

> [!TIP]
> The best practice in computing SCI with Impact Framework is to use the named impacts `operational-carbon` and `embodied-carbon` to represent `O` and `M` in the equation.

## Operational energy

From the above impact we know we need to source some observations for operational carbon, embodied carbon and also the functional unit. 



Moving to a more realistic example, our cloud provider does **not** provide is with energy values for our cpu. Instead all we have is the **cpu utilization**. 

We know our server is running on the **Azure** cloud platform, the instance type is **Azure Standard A2m_v2** and it's in the region **West UK**.

The only other observation we can gather about our server is the **memory utilization**.

So all together all the observations we can gather about our software is:

- `cpu-utilization`, such as 0.2
- `memory-utilization`, such as 0.8
- `cloud/instance-type`, such as Azure Standard A2m_v2
- `cloud/provider`, such as Azure
- `cloud/region`, such as West UK

> [!TIP]
> Using `/` is a useful way to structure related observation parameters together. There are no standards for how you name observation parameters, but a good practice is to structure related observations with a subject/object pattern, like all observations related to the cloud might be good to prepend with `cloud/`. 


### Carbon intensity

REGION

### Embodied Carbon

This is new, we need to compute the embodied carbon of a server and that's not something we have covered 

From he previous...


### Functional Unit

This means that we need to also have the number of requests represented in the observations, so we can divide the carbon by this figure later.

site-visits

### All observations

ALL OF THEM



## Observations














Let's adjust the context in our previous IMP files so they now calculate `operational-carbon` instead of `carbon`.

```yaml
name: server-carbon
description: minimal demo
tags:
initialize:
  plugins:
    energy-from-memory-utilization:        
      method: Coefficient
      path: "builtin"
      config:
        input-parameter: memory-utilization 
        coefficient: 0.00039                
        output-parameter: memory-energy     
    sum-energy:                            
      path: "builtin" 
      method: Sum                                
      config:
        input-parameters:         
          - memory-energy
          - cpu-energy
        output-parameter: operational-energy    # <1>        
    carbon-from-energy:       
      method: Coefficient
      path: "builtin"
      config:
        input-parameter: operational-energy     # <2>        
        coefficient: 163
        output-parameter: operational-carbon    # <3>        
...       
```
- <1>: renamed `energy` to `operational-energy`
- <2>: renamed `energy` to `operational-energy`
- <3>: renamed `carbon` to `operational-carbon`

If we execute the IMP file now it would return this in the outputs:

```yaml
outputs:
    - timestamp: 2023-08-06T00:00
        duration: 3600
        memory-utilization: 8.8
        operational-energy: 0.003432
        operational-carbon: 0.559416
```

## Embodied Carbon

The virtual machine you are using is an `Azure Standard A2m_v2`. [This instance has](https://azure.microsoft.com/en-us/blog/new-av2-series-vm-sizes/) 2 VCPUs, 16 GB memory, a 20 GB SD and no GPUs.

The plugin initialization is extremely simple - you do not have to provide any config data at all unless you want to override some default settings, which you don’t here. You can simply add the following to your `initialize: plugins:` block:

```yaml
initialize:
  plugins:
		embodied-carbon:
		  path: builtin
		  method: SciEmbodied
```

Then the following information can be added to your input array (or you could add it to `defaults` with the same effect.

```yaml
inputs:
	- vCPUs: 2
	- memory: 16
	- SSD: 1
```

This is all that is required for the `SciEmbodied` model to run. It will add the total embodied emissions for the server to the output data using the name `embodied-carbon`.

## Operational & Embodied

Now that you have two components that sum to give the total carbon (operational and embodied) you should rename your existing `carbon` parameter to `operational-carbon`. This means the name `carbon` is freed up for the sum of operational and embodied carbon.

You can add an instance of `Sum` to sum together the embodied and operational carbon components:

```yaml
sum-carbon-components:
  path: "builtin"
  method: Sum
  config:
    input-parameters:
      - operational-carbon
      - embodied-carbon
    output-parameter: carbon
```

## SCI

There is only one more step to calculate the SCI score. You must choose a suitable functional unit and divide your total carbon by it to yield SCI.

Let’s say your application is a website. A suitable functional unit would be unique visits per day. This gives an idea of how carbon efficient your application is, as reducing the SCI score means reducing the carbon emitted by each user. 

You can simply add `site-visits` to your input data, let’s say there were 550 visits. In a real application, this information could come from a service like Google Analytics.

Now, add the SCI builtin to your set of plugins. You have to specify your functional unit in the plugin config, as follows:

```yaml
sci:
  path: "builtin"
  method: Sci
  config:
    functional-unit: site-visits
```

Add `sci` to the component pipeline, and you’ve completed your end-to-end SCI IMP! Now all that’s required is to run it and view the results. 

```yaml
name: memory-utilization-to-carbon

description: two-step demo
tags:
initialize:
  plugins:
    memory-to-energy:
      method: Multiply
      path: builtin
      config:
        input-parameters: [memory-utilization, memory-coefficient]
        output-parameter: memory-energy-kwh
    energy-to-carbon:
      method: Multiply
      path: builtin
      config:
        input-parameters: [energy, carbon-intensity]
        output-parameter: operational-carbon
    interpolate-power-curve:
      method: Interpolation
      path: "builtin"
      config:
        method: linear
        x: [0, 10, 50, 100]
        y: [0.12, 0.32, 0.75, 1.02]
        input-parameter: "cpu-utilization"
        output-parameter: "tdp-multiplier"
    tdp-multiplier-to-power:
      method: Multiply
      path: builtin
      config:
        input-parameters: ["tdp-multiplier", "tdp"]
        output-parameter: "cpu-power"
    power-to-energy-kwh:
      method: Divide
      path: "builtin"
      config:
        numerator: cpu-power
        denominator: 1000
        output: cpu-energy-kwh
    sum-energy-components:
      path: "builtin"
      method: Sum
      config:
        input-parameters:
          - memory-energy-kwh
          - cpu-energy-kwh
        output-parameter: energy
    embodied-carbon:
      path: builtin
      method: SciEmbodied
    sum-carbon-components:
      path: "builtin"
      method: Sum
      config:
        input-parameters:
          - operational-carbon
          - embodied-carbon
        output-parameter: carbon
    sci:
      method: Sci
      path: "builtin"
      config:
        functional-unit: site-visits
 
tree:
  children:
    component-1:
      defaults:
        vCPUs: 2
        memory: 16
        SSD: 1
      pipeline:
        compute:
          - memory-to-energy
          - interpolate-power-curve
          - tdp-multiplier-to-power
          - power-to-energy-kwh
          - sum-energy-components
          - energy-to-carbon
          - embodied-carbon
          - sum-carbon-components
          - sci
      inputs:
        - timestamp: 2023-08-01T00:00
          duration: 3600
          memory-utilization: 8.8
          cpu-utilization: 80
          tdp: 205
          memory-coefficient: 0.00039
          carbon-intensity: 163
          site-visits: 210

```