




# Two-Step Pipeline

---

In this example, you’ll use a single component, and two plugins. The aim is to get comfortable chaining plugins together.

[Diagram of the flow]

## Proxy Observations

Imagine you have a Virtual Machine (VM) running in the cloud. You want to know how much carbon you are emitting. You look into what metrics are exposed via the cloud provider’s monitor API and find all you have available is `memory utilisation`. You will try to use this to **work out your carbon emissions for one hour.**

You make a request to the monitor API, configured to return the average memory utilisation across the last hour. It returns a **value of `55%`**.

Now, you have to do a little research to determine what to do with that number. **Memory utilisation is a proxy measurement for energy consumption** which is in itself a proxy for the metric you really want, which is carbon emissions. So you have to search the literature, look for models that have been proposed elsewhere for turning memory utilisation into energy or carbon.

[**Cloud Carbon Footprint**](https://www.cloudcarbonfootprint.org/) proposes a **coefficient for converting memory utilisation into energy**, which gets you one step closer to your goal.

They suggest that multiplying memory utilisation in gigabytes by a `0.000392 kWh/GBh` is appropriate for a first-order estimate of the energy consumption due to memory. This value is derived from averaging the values proposed by two industry power models.

So, in order to apply this coefficient, you first have to express your memory utilisation in GB. What you have from the API is a percentage. You need to know the total available memory for your instance. 

You can retrieve this information from several sources - you can usually look in your cloud dashboard to find the specs for your virtual machine, or you can look up the instance name in the provider’s documentation or you can refer to our dataset of instance metadata:

https://github.com/Green-Software-Foundation/if-data/blob/main/cloud-metdata-azure-instances.csv

Let’s say your instance is an `Azure Standard A2m_v2`. Our dataset shows that it has 16 GB memory. So your memory utilisation in gigabytes for the past hour is

```mathematica
16 (GB) * 0.55 = 8.8 GB.
```

Now you can apply your coefficient to yield an energy value in kWh.

```mathematica
8.8 (GB) * 0.000392 (kWh/GBh) = 0.003432 kWh
```

Now you can multiply the energy in kWh by the carbon intensity of the energy being used to power your job. Assuming you are running this in the UK, the average carbon intensity is around `163 gCO2e/kWh`, so to get carbon emissions for your virtual machine’s memory utilisation, you can do:

```mathematica
0.003432 (kWh) * 163 (gCO2e/kWh) = 0.559 g Co2e
```

So, in the past hour the VM has **emitted** **`0.559 g CO2e`** due to memory.

## Energy from Memory

So, comparing that to the previous exercise, there is an additional step. Rather than having `energy` given to you, you have to apply another model to get `energy` from memory utilisation.

The output from one model (**memory utilisation to energy**) is the input to the next (**energy to carbon**).

Let’s build this in an IMP file. Start with the boilerplate again:

```yaml
name: memory-to-carbon
description: minimal demo
tags:
initialize:
  plugins:
tree:
  children:
    component1:
      defaults:
      pipeline:
        compute:
      inputs: 
```

You still only have one component, representing your Virtual Machine. **This time you will use two plugins, both doing multiplications**.

Create two instances of the `Multiply` plugin with different names.  

- The first can be `memory-to-energy-component-1` and it will multiply `memory-utilization` by `memory-coefficient` to yield `energy`.

- The second can be called `energy-to-carbon-component-1` and it will multiply `energy` by `carbon-intensity` to yield `carbon`. Add these to the `initialize:plugins` block, as follows:

```yaml
initialize:
  plugins:
    memory-to-energy-component-1:
      method: Multiply
      path: builtin
      config:
        input-parameters: [memory-utilization, memory-coefficient]
        output-parameter: energy
    energy-to-carbon-component-1:
      method: Multiply
      path: builtin
      config:
        input-parameters: [energy, carbon-intensity]
        output-parameter: carbon
```

Notice the output from `memory-to-energy-component-1` is required for `energy-to-carbon-component-1` to execute. 

You can add these plugins to the `pipeline` field for `component-1`:

```yaml
tree:
  children:
    component-1:
      defaults:
      pipeline:
        compute:
          - memory-to-energy-component-1
          - energy-to-carbon-component-1
      inputs: 
```

You now need the following observations parameters in our input array:

- `memory-utilisation`
- `memory-coefficient`
- `carbon-intensity`

```yaml
inputs:
  - timestamp: 2023-08-06T00:00
    duration: 3600
    memory-utilization: 8.8
    memory-coefficient: 0.00039
    carbon-intensity: 163
```

Now you can run the IMP using:

```yaml
if-run -m imp.yml
```

So, you got to your carbon value again, this time you had to make two steps from your observation to your impact:

```yaml
**➜ if-run -m imp.yml**

# start
name: memory-to-carbon
description: minimal demo
tags: null
initialize:
  plugins:
    memory-to-energy-component-1:
      path: builtin
      method: Multiply
      config:
        input-parameters:
          - memory-utilization
          - memory-coefficient
        output-parameter: energy
    energy-to-carbon-component-1:
      path: builtin
      method: Multiply
      config:
        input-parameters:
          - energy
          - carbon-intensity
        output-parameter: carbon
execution:
  command: >-
    /Users/russell/.nvm/versions/node/v22.13.1/bin/node /usr/local/bin/if-run -m
    imp.yml
  environment:
    ...
  status: success
tree:
  children:
    component-1:
      defaults: null
      pipeline:
        compute:
          - memory-to-energy-component-1
          - energy-to-carbon-component-1
      inputs:
        - timestamp: 2023-08-06T00:00
          duration: 3600
          memory-utilization: 8.8
          memory-coefficient: 0.00039
          carbon-intensity: 163
      **outputs:**
        - timestamp: 2023-08-06T00:00
          duration: 3600
          memory-utilization: 8.8
          memory-coefficient: 0.00039
          carbon-intensity: 163
          energy: 0.003432
          **carbon: 0.559416**

# end
```

<aside>
<img src="/icons/computer-chip_blue.svg" alt="/icons/computer-chip_blue.svg" width="40px" />

## Get Hands-on

*You can try building and running this IMP for yourself by breaking out to an interactive environment:*

[green software r&d | Killercoda](https://killercoda.com/jcook/course/if-training-course/exercise-3)

</aside>

## Tutorial

## **Creating your manifest**

In this example, rather than having `energy` given to you, you have to apply another model to get `energy` from memory utilisation. The output from one model (memory utilisation to energy) is the input to the next (energy to carbon).

Let’s build this in a manifest file.

Start with the boilerplate again (`boilerplate.yml` ), which you can open in your editor.

## **Add plugins**

Create two instances of the `Multiply` plugin with different names.  The first can be `memory-to-energy-component-1` and it will multiply `memory-utilization` by `memory-coefficient` to yield `energy` . The second can be called `energy-to-carbon-component-1` and it will multiply `energy` by `carbon-intensity` to yield `carbon` . Add these to the `initialize:plugins` block.

If you need some help, take a peek at `manifest-example.yml` .

## **Invoke the plugins in your component**

Now you have two plugin instances available, you can add them to the `pipeline` for your component. Again, for help, see `manifest-example.yml`

Save your manifest as `manifest.yml`

## **Run your manifest**

Now use `if-run -m manifest.yml -o outputs.yml` to run your manifest.

## **View the outputs**

You just created `outputs.yml` .

Open that file in your editor.

You will see that two new values have been added to your `outputs` : `energy` and `carbon` .

Notice that `energy` was not available in the original manifest. It was created when the `memory-to-energy-component-1` plugin ran. Then it was used as the input to `energy-to-carbon-component-1` .

If you remove `memory-to-energy-component-1` from your pipeline and run the manifest again, it will fail. This is because `energy` is a necessary input to `energy-to-carbon-component-1` . By omitting the first plugin, you are starving the second plugin of its input data.

This is an important concept in Impact Framework because it means the order of plugin execution in each component is very important.

## **Test your learning**

1. Try adding another plugin that depends on a `carbon` value being available. Notice that this plugin will run successfully if it is placed in the last position in the pipeline, but it will fail if it is placed anywhere else.

# Key Takeaways

---

<aside>
<img src="/icons/rocket_green.svg" alt="/icons/rocket_green.svg" width="40px" />

- You learned how to handle IMPs with multiple plugins
- You saw how outputs from one plugin can feed into subsequent plugins as inputs
- You learned how to construct a simple multi-step pipeline in an IMP file using the standard library of plugins

</aside>

---

---