# Essential Concepts

## Manifest Files

Impact framework exists to process IMP files. The **IMP files are where the magic is**.

IMP files are YAML files that conform to a simple format that allows them to be executable and also auditable. They contain the configuration for all the operations that Impact Framework will execute along with all the observational data you have for your system. This is how the IMP is structured:

```yaml
name:
description:
tags:
initialize:
  plugins:
    <PLUGIN-NAME-HERE>:
      method:
      path:
tree:
  children:
    child:
      pipeline:
        observe:
        regroup:
        compute:
      defaults:
      inputs:
        - timestamp: 2023-08-06T00:00
        duration: 3600

```

All the different components of your system are represented individually in the IMP, using simple blocks of YAML that can be organised in hierarchies.

Each component has a structure like this:

```yaml
child:
  pipeline:
    observe:
    regroup:
    compute:
  defaults:
  inputs:
    - timestamp: 2023-08-06T00:00
      duration: 3600
```

You can have as many of these components as you need, nested to any depth. Each one is a building block that **together represent your system architecture**. Each individual block is one logical unit whose carbon emissions can be estimated, for example, a server or a device.

Each block has its own input data - these are the **observations you can make** about this specific component - for example if your component is a server, you might have access to CPU utilisation, memory utilization, data transferred over the network, etc.

- Each component also has its own pipeline. These are the plugins you want to execute on your input data
- Each plugin does one specific action, and the pipeline defines which actions are taken and in which order.
- The complete collection of components, each with their own pipeline and input data, forms the tree.

<aside>
<img src="/icons/book-closed_gray.svg" alt="/icons/book-closed_gray.svg" width="40px" />

Read more about the IMP (aka manifest) https://if.greensoftware.foundation/major-concepts/manifest-file and https://if.greensoftware.foundation/users/how-to-write-manifests.

</aside>


# Observations & Impacts

TODO

# Plugins, Pipelines & Methodologies

---

Pipelines are chains of plugins that operate in sequence over the input data in your IMP file. Your input data is fed through your pipeline of plugins, with each plugin adding a key-value pair to the `inputs` array or updating the value of an existing entry.

Each plugin does some specific operation. The idea is that individual plugins are simple - they do one specific thing only - but they ***act like Impact Legos, building up into complex logic*** operating on your IMP file.

All the plugins first have to be loaded and configured - this is done at the start of the IMP in a section named ``plugins: initialize``. Along with some simple metadata for the IMP, these sections comprise the “context” part of the IMP.

When you pass your IMP to Impact Framework:

- First it uses the context to load the appropriate plugins.
- Then, for each component in the tree, Impact Framework executes the named plugins in order, generating output data that’s stored in the component’s outputs section.
- Then, Impact Framework aggregates the carbon and energy values up the tree. Wherever a component has child components, those children’s carbon and energy values are aggregated together and added to the parent, so you can see the total carbon at every level in your tree.

For example, if you have a system with two data centres, each with two racks, each with ten servers you would:

- Get individual output data for forty servers
- Then each set of twenty servers would get aggregated to give four rack totals
- And those would get aggregated to yield two data center totals
- And then you’d also get an overall “root” total aggregating the two data centers

This is all done under the hood - all you have to do is write your IMP and pass it to `if-run`.

<aside>
<img src="/icons/book-closed_gray.svg" alt="/icons/book-closed_gray.svg" width="40px" />

Read more about https://if.greensoftware.foundation/major-concepts/pipelines and see https://if.greensoftware.foundation/pipelines/

</aside>

# Plugins

---

Plugins are self-contained units of code that do one thing. They can be loaded into IF and chained together in a pipeline so that simple individual plugins can form a complicated procedure for computing an IMP file.

Anyone can build IF plugins. To make them discoverable, we host the [IF Explorer](https://explorer.if.greensoftware.foundation/) website. Here you can search for plugins that you need for your specific use-case. The choice of which plugin to use for which software component comes down to an expert decision by a green software professional:

[IF Explorer](https://explorer.if.greensoftware.foundation/)

<aside>
<img src="/icons/book-closed_gray.svg" alt="/icons/book-closed_gray.svg" width="40px" />

Read more about https://if.greensoftware.foundation/major-concepts/plugins.

See https://if.greensoftware.foundation/developers/how-to-build-plugins and also https://if.greensoftware.foundation/developers/how-to-submit-plugins.

</aside>








---



You can review a manifest from someone else, you can review the manifest 
created above for our website. 



Concept in-line:


⸻

1. Exploring a Manifest File

A manifest file is divided into two main sections:
	•	Context:
This top section includes the title, description, tags, and crucially, the configuration details. It defines the plugins that will be executed and sets the metadata for your IMP.
	•	Tree:
Here, you define the individual system components. Each component is represented by a simple YAML block that includes a pipeline (listing the plugins to execute), optional defaults (common data for all inputs), and the inputs (observations with fields like timestamp and duration).

A simplified component might look like this:

component-1:
  pipeline:
    compute:
      - a-plugin-instance
  defaults:
  inputs:
    - timestamp: '2024-07-22T00:00:00'
      duration: 86400

Test Your Learning:
	1.	What is the title of the manifest file?
	2.	True or False: Individual system components are defined in the tree section.
	3.	How many individual system components are there in the manifest?

Concept in-line:
The clear separation between context and tree helps you keep configuration details (which affect execution) separate from the structural layout of your system. This distinction is key for both reproducibility and transparency.

⸻

2. Understanding Plugins

Within the context section, you load and configure plugins—self‑contained units of code that perform specific operations on your data. For example, a plugin instantiation to convert duration from seconds to hours might look like:

duration-to-hours:
  path: builtin
  method: Coefficient
  config:
    input-parameter: duration
    coefficient: 0.000278
    output-parameter: duration-in-hours

Key Points:
	•	Instance Naming:
The plugin instance is given a descriptive name (duration-to-hours) to indicate its purpose.
	•	Path & Method:
path: builtin indicates that the plugin is from the standard library, and method: Coefficient specifies the type of operation.
	•	Configuration:
The config block tells the plugin which input to use, what constant to multiply it by, and the name of the output field.

Test Your Learning:
	1.	How many plugins are instantiated in the manifest?
	2.	How many instances of the Multiply plugin are used in the manifest?
	3.	Under what name will the result of the memory-energy plugin be added to the outputs array?
	4.	Which parameters will be multiplied together when the cpu-factor-to-wattage plugin instance is executed?

Concept in-line:
Plugins act like building blocks. When chained together in a pipeline, they allow you to perform complex calculations while keeping each step simple and understandable.

⸻

3. Running the Manifest File

Now that you understand the structure and purpose of a manifest file, it’s time to run it.

How to Run:
	•	Command:

if-run -m manifest-1.yml

This command processes your manifest, executes the defined pipelines for each component, and displays the output on the console.

	•	Redirecting Output:
To save the output to a file instead of printing it to the terminal, use:

if-run -m manifest-1.yml -o output-1.yaml



What Happens When You Run an IMP:
	•	Execution Block:
A new section called execution is added to the manifest. This block logs details about your runtime environment (like operating system, Node.js version, Impact Framework version, and execution time) and whether the run was successful.
	•	Outputs Section:
For each component, Impact Framework adds an outputs section. This section replicates your original inputs data but includes new fields generated by your plugins. For example:

memory:
  pipeline:
    compute:
      - memory-coefficient-correction
      - memory-energy
      - energy-to-carbon
      - sci
  defaults:
    grid-intensity: 165
  inputs:
    - timestamp: '2024-07-22T00:00:00'
      duration: 86400
      site-visits: 228
      memory-gb: 3
  outputs:
    - timestamp: '2024-07-22T00:00:00'
      duration: 86400
      site-visits: 228
      memory-gb: 3
      grid-intensity: 165
      memory-coefficient: 0.5644799712
      energy: 1.6934399136000002
      carbon: 279.41758574400006
      sci: 1.2255157269473687


	•	Aggregation:
Additionally, Impact Framework aggregates key values (such as carbon and sci) up through the tree hierarchy, providing totals for grouped components.

Concept in-line:
Running the manifest not only computes your desired outputs but also creates an auditable record of the configuration and the environmental conditions at runtime. This transparency is crucial for verifying and reproducing your results.

⸻

Final Thoughts and Next Steps

In this chapter, you’ve:
	•	Installed Impact Framework and verified its CLI.
	•	Explored a manifest file to understand its structure (context and tree).
	•	Learned about plugins and how they function as discrete operations that can be chained in pipelines.
	•	Run a manifest file, observing how Impact Framework enriches your original data with computed outputs and aggregates values through the tree.

Test Your Understanding:
Review the test your learning questions in each section to ensure you grasp both the practical steps and the underlying concepts.

Next, explore additional modules (like Software Carbon Intensity) or try modifying the manifest to add more components and plugins. Whether you run Impact Framework locally or in an online environment, the goal is to empower you to analyze and reduce the environmental impacts of your software systems.

Happy coding and green computing!